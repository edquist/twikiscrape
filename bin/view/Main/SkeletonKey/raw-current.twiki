
---+ Using Skeleton Key to remotely access data


---++ Introduction

Skeleton Key is a script that allows users to simplify the process of enabling remote access to data and applications through [[http://www.nd.edu/~ccl/software/chirp/][Chirp]] and [[http://www.nd.edu/~ccl/software/parrot/][Parrot]]. When Skeleton Key is invoked, it reads information from a configuration file on what data needs to be made available and how, and then generates a shell script that when run executes your application in an environment where it can access remote data and applications as if they where mounted locally.&amp;nbsp;


---++ Setting up Chirp

Chirp is required in order to access your data remotely.  You&#39;ll need to download the [[http://www.nd.edu/~ccl/software/download.shtml][CCTools tarball]] and untar it in /usr/local/.  Then download the [[https://github.com/DHTC-Tools/UC3/tree/master/skeleton_key/scripts][skeleton key script]].


---++ Invoking Skeleton Key

Skeleton Key can be run as =skeleton_key -c [config_file]=. It will then parse the config_file and generate a shell script called =job_script.sh= that can then be used in submit files or copied to another system and run. 

---++ Application Modifications Required

In order to work with Skeleton Key, applications must be modified in order to function correctly. The application will need to be set to access data from the location specified by the $CHIRP_MOUNT environment variable. For example, if the application normally writes to =/mnt/hadoop/app_data=, it should write to =$CHIRP_MOUNT/app_data= instead. In addition, all CVMFS mounts will have to be accessed as =/cvmfs/repository_name=.



---++ Configuration File Format

Skeleton Key uses configuration files similar to windows ini files to determine what information to share and how to run applications remotely.&amp;nbsp; Sections in the ini file are started using =[Section]=. Options within each section are specified using option_name = value . Everything after the equals sign is assigned to option so the value does not have to be given in quotes. A ; or # character at the start of a line is used to indicate that a line is a comment and should be ignored. In addition, ; can be used in a line to indicate that the following characters are comments and should be ignored.&amp;nbsp; The sections and options in the configuration file Skeleton Key uses are given below.&amp;nbsp; You will need to have at least an =Application= section in order for Skeleton Key to work.




---++ Directories Section

The =Directories= section of the config file indicates which directories exported by Chirp should be shared and with what permissions. This section has the following settings:
| *Name* | *Description* |
| chirp_base | This mandatory setting specifies the path to the directory that Chirp is exporting. |
| read | A comma separated list of directories located in the directory specified in chirp_base that Skeleton Key should make available to the running application with read only privileges.  |
| write | A comma separated list of directories located in the directory specified in chirp_base that Skeleton Key should make available to the running application with read/write privileges.  |


*Note: either read or write needs to be given.*


---++ Application Section

The =Application= section gives information on your application and how it should be run. The setting for this section are as given:
| *Name* | *Description* |
| location  | An optional setting giving an url to a tarball that should be downloaded and untarred be running the script or binary given in the script setting.&amp;nbsp; The file must be a tar.gz file  |
| script  | This mandatory option should have the location of the binary or script to run within the parrot environment.&amp;nbsp; For example, if the application tarball untars into a directory called app, this may be set to ./app/bin/app_binary .&amp;nbsp; Likewise, if parrot_run should run an application using CVMFS, this may be set to something similar to /cvmfs/repo_name/bin/my_app  |
| arguments  | This option should have any arguments that should be passed to the script or binary specified in the script setting  |
| http_proxy  | An optional setting giving a server to use as a http proxy  |




---++ CVMFS Section

The =CVMFS= section can be used to specify CVMFS repositories that should be setup in the environment that your application will run in.&amp;nbsp; All configured repositories will be available as =/cvmfs/repo_name= where repo_name is the specified name of the repository.

| *Name* | *Description* |
| repoN  | This setting should give the repository name. &amp;nbsp; *Important: this name must match the repo name used when setting up the CVMFS master otherwise your application will segfault when trying to access this repository.*  |
| repoN_key  | This setting should give an URL to the public key associated with the CVMFS repository.&amp;nbsp;  |
| repoN_options  | This setting should give options for the CVMFS repository.&amp;nbsp; Each option should be separated by a comma.&amp;nbsp; At a minimum,&amp;nbsp; url must be given.&amp;nbsp; In addition, proxies must be given if http_proxy is not specified in the {{Application}} section.&amp;nbsp;  |
In the settings listed above, N should be replaced with an integer.&amp;nbsp; Each repository that should be made available should have a corresponding repoN and repoN_options setting starting from 1.&amp;nbsp; E.g. the first repository should be specified by repo1 and repo1_options settings; the second by repo2 and repo2_options; and so on.


CVMFS options are described below, only url is necessary.&amp;nbsp; proxies is only needed if http_proxy is not given or the environment does not have HTTP_PROXY set.

| *Option* | *Explanation* |
| *url=URL* | The URL of the CernVM-FS server(s): &#39;url1;url2;...&#39; |
| *proxies=HTTP_PROXIES* | Set the HTTP proxy list, such as &#39;proxy1&amp;#166;proxy2&#39;;  Proxies separated by &#39;&amp;#166;&#39; are randomly chosen for load balancing. Groups of proxies separated by &#39;;&#39; may be specified for failover. If the first group fails, the second group is used, and so on down the chain. |
| *cachedir=DIR* | Where to store disk cache;  |
| *timeout=SECONDS* | Timeout for network operations;  |
| *timeout_direct=SECONDS* | Timeout in for network operations without proxy; default is given by \-T option (PARROT_TIMEOUT) |
| *max_ttl=MINUTES* | Maximum TTL for file catalogs; default: take from catalog |
| *allow_unsigned* | Accept unsigned catalogs (allows man-in-the-middle attacks) |
| *whitelist=URL* | HTTP location of trusted catalog certificates (defaults is /.cvmfswhitelist) |
| *rebuild_cachedb* | Force rebuilding the quota cache db from cache directory |
| *quota_limit=MB* | Limit size of cache. \-1 (the default) means unlimited. |
| | If not \-1, files larger than quota_limit-quota_threshold will not be readable. |
| *quota_threshold=MB* | Cleanup cache until size is &lt;= threshold |
| *deep_mount=prefix* | Path prefix if a repository is mounted on a nested catalog |
| *repo_name=NAME* | Unique name of the mounted repository; default is the name used for this configuration entry |
| *mountpoint=PATH* | Path to root of repository; default is /cvmfs/repo_name |
| *blacklist=FILE* | Local blacklist for invalid certificates. Has precedence over the whitelist. |

---++ Parrot Section


This optional section can be used to specify the location of a tarball with the Parrot binaries that should be used.&amp;nbsp; If this section is not given, then a default set of binaries for the UC3 cluster will be used.&amp;nbsp; The settings for this section are as follow:
| *Name* | *Description* |
| location | URL to a tar.gz file that can be downloaded.&amp;nbsp; The parrot_run binary must be found at {{./parrot/bin/parrot_run}} after untaring the file  |



-- Main.SuchandraThapa - 15 Nov 2012

---+ Writing an OSG Storage Probe

This page provides a rough set of notes and outline for writing a storage probe.  If you use the Gratia Python API for services probes and provide the correct information for a single site, you can get storage reports for your site.

---+ Install dependencies

We recommend that you use RPMs found in the ProbeInstallation document.  As we will use python-only probes and Gratia doesn&#39;t install to standard linux places, you can use the same probe for SL4 or SL5 on 32 or 64-bit machines.  Install
   * gratia-probe-common
   * gratia-probe-services
(Direct link here: http://gratia.fnal.gov/Files/probe/RPMS/) Version 1.04.5 is the minimum version required.

Install these RPMs and put the directories /opt/vdt/gratia/probe/common and /opt/vdt/gratia/probe/services into your python path.  I use the following snippet of code to bootstrap my python module:

&lt;verbatim&gt;
# Bootstrap our python configuration.  This should allow us to discover the
# configurations in the case where our environment wasn&#39;t really configured
# correctly.
sys.path.append(&#39;.&#39;)
gratia_path = os.path.expandvars(&#39;/opt/vdt/gratia/probe/common&#39;)
if gratia_path not in sys.path and os.path.exists(gratia_path):
    sys.path.append(gratia_path)
gratia_path = os.path.expandvars(&#39;/opt/vdt/gratia/probe/services&#39;)
if gratia_path not in sys.path and os.path.exists(gratia_path):
    sys.path.append(gratia_path)
if &#39;VDT_LOCATION&#39; in os.environ:
    gratia_path = os.path.expandvars(&#39;$VDT_LOCATION/gratia/probe/common&#39;)
    if gratia_path not in sys.path and os.path.exists(gratia_path):
        sys.path.append(gratia_path)
    gratia_path = os.path.expandvars(&#39;$VDT_LOCATION/gratia/probe/services&#39;)
    if gratia_path not in sys.path and os.path.exists(gratia_path):
        sys.path.append(gratia_path)

import Gratia
import StorageElement
import StorageElementRecord
&lt;/verbatim&gt;

---+ Terminology

The storage information is divided into two different record types (as opposed to the transfer probes, which simply piggybacked onto the existing !JobUsageRecord).  The !StorageElement class mainly holds static information about the topology of the storage element.  The !StorageElementRecord corresponds to a storage measurement for some entity in the !StorageElement.

Instead of trying to come up with a database schema to match every conceivable storage element, we allow you to make arbitrary record types and specify parent-child relationships between any two unique components in the SE.  Because Gratia uses a relational database, we end up with a very poorly normalized database schema.  In advance, I apologize.  For a defined subset of these configurations, if you fill in information, we can automatically turn your reported data into storage reports emailed out to site admins.

The table below outlines the different pieces of terminology we use:

---++ !StorageElement
These are the semi-static, topology-related parts of the storage element accounting
| *Term* | *Must be used?* | *Explanation* | 
| Timestamp | Yes | Timestamp of when this was recorded.  Can either be a string in form &quot;YYYY-MM-DDTHH:MM:SSZ&quot; or numeric output of time.time().  Does NOT get automatically set. |
| !SEUniqueID | Yes | This is the !UniqueID of the SE; usually, it is the hostname of the primary SRM endpoint.  If there is no primary SRM endpoint, try to set this to the host name of the &quot;primary&quot; node in the system.  This must be a globally-unique string, hence our suggestion to use a FQDN |
| Space Type | Yes | The type of the logical space.  Suggested strings are given below. Note that some of these refer to raw disk used (Pool, !PoolGroup) while others refer to logical usage within the storage element (Quota, !Trash.StorageSpaceReservation, Directory).  The storage report undesrtands quotas, directories, and SE space types.  It can also be taught to understand space reservations if desired. |
| Space Name | Yes | An arbitrary name for the space.  Must be unique for the SE. |
| Space Unique ID | Yes | This string is generated by the tool and *must* have the following form: &lt;SE !UniqueID&gt;:&lt;space type&gt;:&lt;space name&gt; This space name must be unique for the entire SE. |
| Parent ID | Yes | This string (may be null) is set to the space unique ID for any logical parent that the space might have.  For example, a pool might have a parent pool group.  A pool group might have a parent link group.  A space reservation would have a parent link group. (All for dCache).  For many of the spaces, the parent space might be the entire storage element.  See the above comment about the Space Unique ID to know how to generate the Parent ID from a given space.  Note that a Parent&#39;s space does not have to add up to the sum of its children!  For example, a SE could have 10TB, and given 20 users with a 1TB quota. |
| VO | No | Any VO (or group) allowed to write into the space.  May be comma-seperated.  May be a wildcard.  May be left blank.  Not validated against a list of known VOs. |
| Owner | No | The owner of a space.  Might be a person&#39;s name (Johnny Public), a unix username, or a certificate&#39;s DN |

Sample strings for !SpaceType:
   * !Trash.StorageSpaceReservation: A SRM space reservation
   * Pool: A single disk server
   * !PoolGroup: A group of disk servers
   * !LinkGroup: A group of PoolGroups (dCache specific)
   * !StaticSpaceReservation: A staticly configured space reservation (!BeStMan)
   * Quota: A quota on the storage element.
   * Directory: All space used inside a specific directory.
   * SE: The entire Storage Element
   * Area: Some logical area in the SE.  Can be part of the namespace, or maybe a grouping of space reservations.

---++ !StorageElementRecord
These are the dynamic pieces of information related to a specific measurement in time.
| *Term* | *Must be used?* | *Explanation* | 
| Timestamp | Yes | Timestamp of when this was recorded.  Can either be a string in form &quot;YYYY-MM-DDTHH:MM:SSZ&quot; or numeric output of time.time().  Does NOT get automatically set. |
| !MeasurementType | Yes | Either &quot;logical&quot; or &quot;raw&quot;; refers to whether this is referring to space used on a hard drive, or the amount of space a user could use (taking replication into account, for example). |
| !FreeSpace | No | Some measurement of free space (logical or raw, depending on the space type).  Must be inputted in BYTES |
| !UsedSpace | No | Some measurement of used space in the SE area |
| !TotalSpace | No | Measurement of the area&#39;s size; in many cases, should be FreeSpace+UsedSpace.  In the case of a quota, this should be the size of the quota. |
| !FileCount | No | Number of files in the area |
| !FileCountLimit | No | Maximum number of files in the area |

While !FreeSpace, !UsedSpace, !TotalSpace, and !FileCount are not all required, if they are all left blank, the record may be ignored.

---++ Other information

Many storage elements have additional arbitrary data that they would like to report.  For example, HDFS has a lightweight fsck utility that takes a few seconds to run and reports the general state of the system.  If such information is pertinent, you can send a !UsageRecord containing arbitrary XML.

The !UsageRecord must conform to the following:
   * !ResourceType must be set to *Storage-CustomInfo*
   * !AdditionalInfo must contain a key-value pair of *CustomInfo* and *CommandOutput*
   * Status must be set to the exit code of the storage command used.  Use this to report failures in collecting data
   * !StartTime and !EndTime must be populated, preferably to the start and end time of the command run, respectively.
   * !JobName should be set to the command run.
   * !ProjectName must be set to the Space Unique ID of the SE.
   * Call !GenericAddToList with key *CommandOutput* and value of XML-escaped output of the command.

I use a generic function called &quot;collect_data&quot; to run an arbitrary command and send a record containing its output:

&lt;verbatim&gt;
import time
import xml.sax.saxutils

import Gratia

def collect_data(cmd, name, se):
    &quot;&quot;&quot;
    Parameters:
       - cmd: The command to run
       - name: The display name of the information returned.  Used as a header in the storage report
       - se: The UniqueID of the associated SE.
    &quot;&quot;&quot;
    time_start = time.time()
    fd = os.popen(cmd)
    output = fd.read()
    result = fd.close()
    time_end = time.time()
    if result:
        output = &quot;WARNING: Non-zero exit code\n&quot; + output
    else:
        result = 0
    output = xml.sax.saxutils.escape(output)
    ur = Gratia.UsageRecord()
    ur.StartTime(time_start)
    ur.ResourceType(&quot;Storage-CustomInfo&quot;)
    ur.AdditionalInfo(&quot;CustomInfo&quot;, &quot;CommandOutput&quot;)
    ur.GenericAddToList(&quot;CommandOutput&quot;, output)
    ur.Status(str(result))
    ur.WallDuration(time_end - time_start)
    ur.EndTime(time_end)
    ur.JobName(name, description=cmd)
    ur.ProjectName(&#39;%s:SE:%s&#39; % (se, se))
    Gratia.Send(ur)
&lt;/verbatim&gt;

---+ Entries for Storage Report

The Storage report requires the following records:
   * !StorageElement and !StorageElementRecord for the &quot;SE&quot; space type.  The measurement type must be &quot;raw&quot;.
   * !StorageElement for at least one area in the system.
   * At least one !StorageElement and !StorageElementRecord for a directory, quota, or space reservation within the area.

There will be one column for yesterday&#39;s record, one column for the day before that, and one column for 7 days previous.
Additionally, the storage report will create a section for each uniquely named &quot;Other information&quot; as described above.  There will be one table per area.  For example, CMS sites may have one area for users, one area for simulated data, and one area for detector data.

---+ Examples.

This is the part you were looking for.  I&#39;ll illustrate records I use for our entire SE, a record for a single datanode, a record for an area in the SE, and a record for a quota.

---++ SE
!StorageElement:
&lt;verbatim&gt;
    sa = StorageElement.StorageElement()
    timestamp = time.time()
    se = &quot;hadoop-name.unl.edu&quot;
    name = &quot;Nebraska Hadoop&quot;
    unique_id = &#39;%s:SE:%s&#39; % (se, se)
    parent_id = &#39;%s:SE:%s&#39; % (se, se) # Note that the SE is its own parent.
    sa.UniqueID(unique_id) 
    sa.Name(name)
    sa.SE(se)
    sa.SpaceType(&#39;SE&#39;)
    sa.Implementation(&#39;Hadoop&#39;)
    sa.Version(&quot;0.19.2&quot;)
    sa.Status(&#39;Production&#39;)
    sa.ParentID(parent_id)
    sa.Timestamp(timestamp)
    Gratia.Send(sa)
&lt;/verbatim&gt;

!StorageElementRecord:
&lt;verbatim&gt;
    sar = StorageElementRecord.StorageElementRecord()
    timestamp = time.time()
    se = &quot;hadoop-name.unl.edu&quot;
    name = &quot;Nebraska Hadoop&quot;
    unique_id = &#39;%s:SE:%s&#39; % (se, se)
    parent_id = &#39;%s:SE:%s&#39; % (se, se)
    sar.UniqueID(unique_id)
    sar.MeasurementType(&#39;raw&#39;)
    sar.StorageType(&#39;disk&#39;)
    sar.TotalSpace(12345) # Some number in bytes
    sar.FreeSpace(12340) # Some number in bytes
    sar.UsedSpace(5) # Again, in bytes.
    sar.Timestamp(timestamp)
    sar.FileCount(file_count)
    if quota != &#39;none&#39;:
        sar.FileCountLimit(quota)
    Gratia.Send(sar)
&lt;/verbatim&gt;

---++ Pool

Pools are not currently used in the storage report (but definitely could be added...)

&lt;verbatim&gt;
    name = &quot;node254&quot;
    se = &quot;hadoop-unl.name.edu&quot;
    unique_id = &#39;%s:Pool:%s&#39; % (se, name)
    parent_id = &#39;%s:SE:%s&#39; % (se, se)
    sa = StorageElement.StorageElement()
    sar = StorageElementRecord.StorageElementRecord()
    sa.UniqueID(unique_id)
    sa.Name(name)
    sa.SE(se)
    sa.SpaceType(&#39;Pool&#39;)
    sa.Implementation(&#39;Hadoop&#39;)
    sa.Version(&quot;0.19.2&quot;)
    sa.Status(status)
    sa.ParentID(parent_id)
    sa.Timestamp(timestamp)
    sar.Timestamp(timestamp)
    sar.UniqueID(unique_id)
    sar.MeasurementType(&#39;raw&#39;)
    sar.StorageType(&#39;disk&#39;)
    sar.TotalSpace(node.get(&#39;Configured Capacity&#39;, &#39;0&#39;).split()[0])
    sar.FreeSpace(node.get(&#39;DFS Remaining&#39;, &#39;0&#39;).split(&#39;(&#39;)[0].strip())
    sar.UsedSpace(node.get(&#39;DFS Used&#39;, &#39;0&#39;).split()[0])
    Gratia.Send(sa)
    Gratia.Send(sar)
&lt;/verbatim&gt;

---++ Area 

Note that for areas, only a !StorageElement is required.

&lt;verbatim&gt;
        se = &quot;hadoop-name.unl.edu&quot;
        space_type = &quot;Area&quot;
        name = &quot;CMS /store/user&quot;
        sa = StorageElement.StorageElement()
        unique_id = &#39;%s:%s:%s&#39; % (se, space_type, name)
        parent_id = &#39;%s:SE:%s&#39; % (se, se)
        sa.UniqueID(unique_id)
        sa.Name(name)
        sa.SE(se)
        sa.SpaceType(space_type)
        sa.Implementation(&#39;Hadoop&#39;)
        sa.Version(&quot;0.19.2&quot;)
        sa.Status(&#39;Production&#39;)
        sa.ParentID(parent_id)
        sa.Timestamp(time.time())
        Gratia.Send(sa)
&lt;/verbatim&gt;

---++ Directory/Quota measurement

Notes:
   * The parent name refers to the parent area
   * This is a logical measurement; i.e., we are looking at how many bytes of user data there is, regardless of how many hard drive bytes it takes to store it.

&lt;verbatim&gt;
        space_name = &quot;/store/user/brian&quot;
        area_name = &quot;CMS /store/user&quot;
        space_unique_id = &#39;%s:%s:%s&#39; % (se, space_type, space_name)
        parent_id = &#39;%s:%s:%s&#39; % (se, &#39;Area&#39;, area.name)
        sa.Name(space_name)
        sa.SE(se)
        sa.UniqueID(space_unique_id)
        sa.SpaceType(space_type)
        sa.Implementation(&quot;Hadoop&quot;)
        sa.Version(get_version(cp))
        sa.Status(&quot;Production&quot;)
        sa.ParentID(parent_id)
        sar.UniqueID(space_unique_id)
        sar.MeasurementType(measurement_type)
        sar.StorageType(storage_type)
        sar.TotalSpace(size)
        sar.FreeSpace(0)
        sar.FileCountLimit(0)
        sar.FileCount(file_count)
        sar.UsedSpace(size)
        sar.Timestamp(timestamp)
        sa.Timestamp(timestamp)
        if quota != &#39;none&#39;:
                sar.FileCountLimit(quota)
        if space_quota != &#39;none&#39;:
                sar.TotalSpace(space_quota)
                sar.FreeSpace(remaining_space_quota)
        Gratia.Send(sa)
        Gratia.Send(sar)
&lt;/verbatim&gt;

---+ Example Report Output

The example below shows the top part of a storage report.  This should give you a feel of what output the site admin gets with the raw information about the whole SE and one area with a few directories

&lt;verbatim&gt;
============================================================
  The Hadoop Chronicle | 86 % | 2009-10-28
============================================================

--------------------
| Global Storage   |
-----------------------------------------------------
|                  |  Today  | Yesterday | One Week |
-----------------------------------------------------
| Total Space (GB) | 429,863 |   457,113 |  460,744 |
| Free Space (GB)  |  62,082 |    91,642 |  100,926 |
| Used Space (GB)  | 367,781 |   365,471 |  359,818 |
| Used Percentage  |     86% |       80% |      78% |
-----------------------------------------------------

--------------
| CMS /store |
-------------------------------------------------------------------------------------------------------------
|           Path           | Size(GB) | 1 Day Change | 7 Day Change | # Files | 1 Day Change | 7 Day Change |
-------------------------------------------------------------------------------------------------------------
| /store/user              |      773 |            0 |            0 |   5,232 |            0 |            0 |
| /store/mc                |  128,875 |          508 |        2,375 | 109,460 |          226 |        1,165 |
| /store/relval            |        8 | UNKNOWN      | UNKNOWN      |      11 | UNKNOWN      | UNKNOWN      |
| /store/test              |        0 |            0 |            0 |     694 |            0 |            0 |
| /store/results           |      487 |            0 |            0 |     302 |            0 |            0 |
| /store/phedex_monarctest |      729 |            0 |            0 |     257 |            0 |            0 |
| /store/unmerged          |      174 |           29 |           64 |  25,351 |        1,740 |       13,912 |
| /store/CSA07             |        0 |            0 |            0 |       0 |            0 |            0 |
| /store/data              |    1,678 |            0 |            0 |     433 |            0 |            0 |
| /store/PhEDEx_LoadTest07 |       10 |            0 |            3 |       6 |           -1 |           -1 |
| /store/group             |      389 |            0 |            0 |     701 |            0 |            0 |
-------------------------------------------------------------------------------------------------------------
&lt;/verbatim&gt;

-- Main.BrianBockelman - 29 Oct 2009
